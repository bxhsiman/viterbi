//==============================================================================
// 文件名: control.v
// 描述: Viterbi解码器控制单元，统一管理整个解码器的时序和状态
//
// 模块功能和原理:
// 1. 控制器是Viterbi解码器的"大脑"，负责协调各个功能模块的工作时序
// 2. 主要功能包括：
//    - 双时钟生成: 从主时钟CLOCK生成Clock1和Clock2
//    - 状态计数: 管理ACSPage和ACSSegment计数器
//    - 时序控制: 生成Init、Hold、CompareStart等控制信号
//    - 回溯使能: 在适当时机启动路径回溯(TB_EN)
//
// 工作流程:
// 1. 将输入主时钟4分频生成两个相位不同的工作时钟
// 2. 使用ACSSegment(0-63)跟踪当前处理的状态段
// 3. 使用ACSPage(0-63)跟踪当前处理的码字
// 4. 在适当的时序点生成各种控制信号
// 5. 在处理足够数据后启用路径回溯功能
//
// 关键时序点:
// - ACSSegment=0x3E(62): 码字处理结束，产生Hold信号
// - ACSSegment=0x3F(63): 码字处理开始，产生Init信号  
// - ACSPage=0x3E且ACSSegment=0x3F: 启用回溯(TB_EN)
// - 前K-1个码字: 延迟启动比较器，等待收敛
//==============================================================================

`include "../params.v"

//==============================================================================
// 模块名: CONTROL
// 功能: Viterbi解码器主控制器，管理整个解码过程的时序控制
//
// 工作原理:
// 1. 时钟管理: 生成Clock1和Clock2双相时钟系统
// 2. 状态跟踪: 使用ACSPage和ACSSegment跟踪解码进度
// 3. 信号生成: 在关键时序点产生控制信号
// 4. 启动控制: 管理各功能模块的启动时序
//
// 输入: Reset(复位), CLOCK(主时钟), Active(工作使能)
// 输出: 双时钟 + 计数器 + 各种控制信号
//==============================================================================
module CONTROL (Reset, CLOCK, Clock1, Clock2, ACSPage, ACSSegment, Active,  
        CompareStart, Hold, Init, TB_EN); 

// 输入信号定义
input Reset;                          // 复位信号，低电平有效
input CLOCK;                          // 主时钟输入
input Active;                         // 解码器工作使能信号

// 时钟输出
output Clock1, Clock2;                // 双相工作时钟，频率为CLOCK的1/4

// 计数器输出  
output [`WD_FSM-1:0] ACSSegment;     // ACS段计数器(0-63)，指示当前处理的状态段
output [`WD_DEPTH-1:0] ACSPage;      // 页计数器(0-63)，指示当前处理的码字序号

// 控制信号输出
output Hold;                          // 码字处理结束信号
output Init;                          // 码字处理开始信号  
output CompareStart;                  // ACS比较器启动信号
output TB_EN;                         // 路径回溯使能信号

// 内部寄存器和信号
reg [`WD_FSM-1:0] ACSSegment;        // ACS段计数器寄存器(6位: 0-63)
reg [`WD_DEPTH-1:0] ACSPage;         // 页计数器寄存器(6位: 0-63)
reg Init, Hold;                       // 码字开始/结束信号寄存器
reg TB_EN;                           // 回溯使能寄存器
reg CompareStart;                    // 比较启动寄存器
reg [3:0] CompareCount;              // 比较计数器(4位: 0-15)
reg count;                           // 主时钟分频计数器
reg Clock1, Clock2;                  // 双时钟寄存器

// 关键事件信号
wire EVENT_1, EVENT_0;               // 特殊时序事件标志

//==============================================================================
// 双时钟生成模块
// 功能: 将主时钟CLOCK 4分频，生成两个相位错开的工作时钟
// Clock1和Clock2的关系: 交替工作，互不重叠，频率为CLOCK的1/4
//==============================================================================

   //===========================================================================
   // 主时钟2分频器
   // count信号每个CLOCK周期翻转一次，作为后续时钟生成的基准
   //===========================================================================
   always @(posedge CLOCK or negedge Reset)  
      if (~Reset) count <= 0;               // 复位时count清零
      else count <= ~count;                 // 每个CLOCK上升沿翻转count

   //===========================================================================
   // 双相时钟生成器
   // 根据count的值选择性地翻转Clock1或Clock2
   // 实现4分频和相位错开的效果
   //===========================================================================
   always @(posedge CLOCK or negedge Reset)   
   begin  
      if (~Reset)                           // 复位时两个时钟都清零
        begin 
           Clock1 <= 0;  
           Clock2 <= 0; 
        end 
      else
        begin 
          if (count) Clock1 <= ~Clock1;     // count=1时翻转Clock1(周期400ns)
          if (~count) Clock2 <= ~Clock2;    // count=0时翻转Clock2(周期400ns)
        end 
   end

//==============================================================================
// 主控制逻辑模块
// 功能: 管理ACSPage、ACSSegment计数器和主要控制信号
// 时钟域: Clock1上升沿
//==============================================================================

   //===========================================================================
   // 关键事件定义
   // EVENT_1: ACSSegment达到62(0x3E)，表示当前码字处理即将结束
   // EVENT_0: ACSSegment达到63(0x3F)，表示进入下一个码字处理周期
   //===========================================================================
   assign EVENT_1 = (ACSSegment == 6'h3E);  // 二进制: 111110
   assign EVENT_0 = (ACSSegment == 6'h3F);  // 二进制: 111111

   //===========================================================================
   // 主状态机和计数器控制 (Clock1上升沿触发)
   //===========================================================================
   always @(posedge Clock1 or negedge Reset)
   begin 
     if (~Reset)                            // 复位状态
        begin 
           {ACSPage,ACSSegment} <= 12'hFFF; // 初始化为全1(4095)，下次+1后归零
           Init <= 0;                      // 初始化信号清零
           Hold <= 0;                      // 保持信号清零
           TB_EN <= 0;                     // 回溯使能清零
        end      
     else if (Active)                       // 解码器工作状态
          begin 
            //=================================================================
            // 计数器递增逻辑
            // 每个Clock1周期，12位计数器{ACSPage,ACSSegment}递增1
            // ACSSegment: 0→63循环，跟踪当前状态段
            // ACSPage: ACSSegment溢出时递增，跟踪码字序号
            //=================================================================
             {ACSPage,ACSSegment} <= {ACSPage,ACSSegment} + 1; 

            //=================================================================
            // 码字边界控制信号生成
            //=================================================================
             if (EVENT_1)                   // ACSSegment=62: 码字即将结束
               begin 
                 Init <= 0;                // 清除初始化标志
                 Hold <= 1;                // 设置保持信号，通知各模块码字结束
               end  
             else if (EVENT_0)              // ACSSegment=63: 新码字开始
               begin 
                 Init <= 1;                // 设置初始化标志，通知各模块新码字开始
                 Hold <= 0;                // 清除保持信号
               end  
             else 
               begin 
                 {Init,Hold} <= 0;         // 正常处理期间，两个信号都为0
               end 

            //=================================================================
            // 路径回溯启动控制
            // 条件: ACSSegment=63 且 ACSPage=62
            // 含义: 处理了62个完整码字后，启动路径回溯功能
            // 原因: 需要足够的历史数据才能进行有效的路径回溯
            //=================================================================
             if ((ACSSegment == 6'h3F) && (ACSPage == 6'h3E)) 
               TB_EN <= 1;                 // 启用路径回溯单元
        end 
   end

//==============================================================================
// ACS比较器启动控制模块
// 功能: 管理ACS单元的CompareStart信号，处理约束长度相关的启动延迟
// 时钟域: Clock2上升沿
//
// 原理: 
// - 前K-1个码字不进行ACS比较，因为路径尚未收敛
// - K是约束长度(`CONSTRAINT)，对于约束长度9的卷积码，K-1=8
// - 在前8个EVENT_1事件后，等到EVENT_0时才启动比较器
//==============================================================================
   always @(posedge Clock2 or negedge Reset)  
   begin  
     if (~Reset)                            // 复位状态
          begin  
              CompareCount <= 0;            // 计数器清零
              CompareStart <= 0;            // 比较启动信号清零
          end 
     else 
       begin 
          //===================================================================
          // 约束长度计数逻辑
          // 在比较器未启动期间，每次EVENT_1事件时计数器递增
          // 目的: 等待足够的码字以确保路径收敛
          //===================================================================
          if (~CompareStart && EVENT_1) 
            CompareCount <= CompareCount + 1; 

          //===================================================================
          // 比较器启动条件检查
          // 当计数达到CONSTRAINT-1且遇到EVENT_0时，启动ACS比较器
          // CONSTRAINT-1 = 8 (对于约束长度9的卷积码)
          //===================================================================
          if (CompareCount == `CONSTRAINT-1 && EVENT_0) 
            CompareStart <= 1;             // 永久启动比较器
       end 
   end

endmodule

//==============================================================================
// 设计说明:
//
// 1. 时钟设计:
//    - 主时钟CLOCK经过4分频生成Clock1和Clock2
//    - Clock1和Clock2相位错开，避免竞争冒险
//    - Clock1用于主控制逻辑，Clock2用于比较器控制
//
// 2. 计数器设计:
//    - ACSSegment: 6位计数器(0-63)，跟踪256个状态的处理进度
//    - ACSPage: 6位计数器(0-63)，跟踪处理的码字数量
//    - 12位联合计数器实现连续计数
//
// 3. 控制信号时序:
//    - Init: 在ACSSegment=63时产生，标志新码字开始
//    - Hold: 在ACSSegment=62时产生，标志码字处理结束
//    - CompareStart: 延迟启动，等待路径收敛
//    - TB_EN: 在足够数据积累后启动回溯
//
// 4. 约束长度处理:
//    - 前K-1个码字不启动比较器，避免未收敛的错误决策
//    - 使用CompareCount跟踪已处理的码字数量
//    - 确保Viterbi算法的正确收敛性能
//==============================================================================